CCS PCM C Compiler, Version 5.021, 29682               04-nov-16 12:32

               Filename:   C:\Users\Administrator\Desktop\can-communication\can-communication.lst

               ROM used:   1100 words (13%)
                           Largest free fragment is 2048
               RAM used:   25 (7%) at main() level
                           53 (14%) worst case
               Stack used: 3 locations
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   421
0003:  NOP
.................... #include <main.h> 
.................... #include <16F877A.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
0004:  DATA CE,27
0005:  DATA 20,22
0006:  DATA 41,2A
0007:  DATA 41,00
0008:  DATA D0,22
0009:  DATA 44,1D
000A:  DATA A0,12
000B:  DATA EC,3A
000C:  DATA FC,12
000D:  DATA EC,3A
000E:  DATA 00,00
000F:  DATA C8,22
0010:  DATA 4C,26
0011:  DATA 4F,10
0012:  DATA D7,27
0013:  DATA 52,26
0014:  DATA 44,00
0015:  DATA 52,2C
0016:  DATA 20,27
0017:  DATA 4F,22
0018:  DATA 45,00
0019:  DATA 54,2C
001A:  DATA 20,27
001B:  DATA 4F,22
001C:  DATA 45,00
*
019A:  MOVF   31,W
019B:  MOVWF  04
019C:  BCF    03.7
019D:  BTFSC  32.0
019E:  BSF    03.7
019F:  MOVF   4F,W
01A0:  MOVWF  00
01A1:  INCF   04,F
01A2:  CLRF   00
01A3:  INCF   31,F
01A4:  BTFSC  03.2
01A5:  INCF   32,F
01A6:  RETURN
01A7:  MOVF   0B,W
01A8:  MOVWF  42
01A9:  BCF    0B.7
01AA:  BSF    03.5
01AB:  BSF    03.6
01AC:  BSF    0C.7
01AD:  BSF    0C.0
01AE:  NOP
01AF:  NOP
01B0:  BCF    03.5
01B1:  BCF    03.6
01B2:  BTFSC  42.7
01B3:  BSF    0B.7
01B4:  BSF    03.6
01B5:  MOVF   0C,W
01B6:  ANDLW  7F
01B7:  BTFSC  03.2
01B8:  GOTO   1FB
01B9:  BCF    03.6
01BA:  MOVWF  42
01BB:  BSF    03.6
01BC:  MOVF   0D,W
01BD:  BCF    03.6
01BE:  MOVWF  43
01BF:  BSF    03.6
01C0:  MOVF   0F,W
01C1:  BCF    03.6
01C2:  MOVWF  44
01C3:  MOVF   42,W
01C4:  MOVWF  4F
01C5:  CALL   19A
01C6:  MOVF   43,W
01C7:  BSF    03.6
01C8:  MOVWF  0D
01C9:  BCF    03.6
01CA:  MOVF   44,W
01CB:  BSF    03.6
01CC:  MOVWF  0F
01CD:  BCF    03.6
01CE:  MOVF   0B,W
01CF:  MOVWF  45
01D0:  BCF    0B.7
01D1:  BSF    03.5
01D2:  BSF    03.6
01D3:  BSF    0C.7
01D4:  BSF    0C.0
01D5:  NOP
01D6:  NOP
01D7:  BCF    03.5
01D8:  BCF    03.6
01D9:  BTFSC  45.7
01DA:  BSF    0B.7
01DB:  BSF    03.6
01DC:  RLF    0C,W
01DD:  RLF    0E,W
01DE:  ANDLW  7F
01DF:  BTFSC  03.2
01E0:  GOTO   1FB
01E1:  BCF    03.6
01E2:  MOVWF  42
01E3:  BSF    03.6
01E4:  MOVF   0D,W
01E5:  BCF    03.6
01E6:  MOVWF  43
01E7:  BSF    03.6
01E8:  MOVF   0F,W
01E9:  BCF    03.6
01EA:  MOVWF  44
01EB:  MOVF   42,W
01EC:  MOVWF  4F
01ED:  CALL   19A
01EE:  MOVF   43,W
01EF:  BSF    03.6
01F0:  MOVWF  0D
01F1:  BCF    03.6
01F2:  MOVF   44,W
01F3:  BSF    03.6
01F4:  MOVWF  0F
01F5:  INCF   0D,F
01F6:  BTFSC  03.2
01F7:  INCF   0F,F
01F8:  BCF    03.6
01F9:  GOTO   1A7
01FA:  BSF    03.6
01FB:  BCF    03.6
01FC:  RETURN
*
02F3:  CLRF   4E
02F4:  MOVF   04,W
02F5:  MOVWF  4D
02F6:  BCF    4E.0
02F7:  BTFSC  03.7
02F8:  BSF    4E.0
02F9:  SWAPF  47,W
02FA:  IORLW  F0
02FB:  MOVWF  49
02FC:  ADDWF  49,F
02FD:  ADDLW  E2
02FE:  MOVWF  4A
02FF:  ADDLW  32
0300:  MOVWF  4C
0301:  MOVF   47,W
0302:  ANDLW  0F
0303:  ADDWF  4A,F
0304:  ADDWF  4A,F
0305:  ADDWF  4C,F
0306:  ADDLW  E9
0307:  MOVWF  4B
0308:  ADDWF  4B,F
0309:  ADDWF  4B,F
030A:  SWAPF  46,W
030B:  ANDLW  0F
030C:  ADDWF  4B,F
030D:  ADDWF  4C,F
030E:  RLF    4B,F
030F:  RLF    4C,F
0310:  COMF   4C,F
0311:  RLF    4C,F
0312:  MOVF   46,W
0313:  ANDLW  0F
0314:  ADDWF  4C,F
0315:  RLF    49,F
0316:  MOVLW  07
0317:  MOVWF  48
0318:  MOVLW  0A
0319:  ADDWF  4C,F
031A:  DECF   4B,F
031B:  BTFSS  03.0
031C:  GOTO   319
031D:  ADDWF  4B,F
031E:  DECF   4A,F
031F:  BTFSS  03.0
0320:  GOTO   31D
0321:  ADDWF  4A,F
0322:  DECF   49,F
0323:  BTFSS  03.0
0324:  GOTO   321
0325:  ADDWF  49,F
0326:  DECF   48,F
0327:  BTFSS  03.0
0328:  GOTO   325
0329:  MOVLW  48
032A:  MOVWF  04
032B:  BCF    03.7
032C:  MOVLW  07
032D:  ANDWF  4D,W
032E:  BCF    4D.6
032F:  ADDWF  04,F
0330:  MOVLW  4C
0331:  SUBWF  04,W
0332:  BTFSC  03.2
0333:  BSF    4D.6
0334:  MOVF   00,W
0335:  MOVWF  77
0336:  BTFSS  03.2
0337:  GOTO   340
0338:  BTFSC  4D.6
0339:  GOTO   340
033A:  BTFSC  4D.4
033B:  GOTO   352
033C:  BTFSC  4D.3
033D:  GOTO   340
033E:  MOVLW  20
033F:  GOTO   343
0340:  BSF    4D.3
0341:  BCF    4D.4
0342:  MOVLW  30
0343:  ADDWF  77,F
0344:  CLRF   47
0345:  MOVF   04,W
0346:  MOVWF  46
0347:  BCF    47.0
0348:  BTFSC  03.7
0349:  BSF    47.0
034A:  MOVF   77,W
034B:  MOVWF  4F
034C:  CALL   19A
034D:  MOVF   46,W
034E:  MOVWF  04
034F:  BCF    03.7
0350:  BTFSC  47.0
0351:  BSF    03.7
0352:  INCF   04,F
0353:  BTFSS  4D.6
0354:  GOTO   330
0355:  RETURN
*
039A:  MOVF   0B,W
039B:  MOVWF  47
039C:  BCF    0B.7
039D:  BSF    03.5
039E:  BSF    03.6
039F:  BSF    0C.7
03A0:  BSF    0C.0
03A1:  NOP
03A2:  NOP
03A3:  BCF    03.5
03A4:  BCF    03.6
03A5:  BTFSC  47.7
03A6:  BSF    0B.7
03A7:  BTFSC  03.0
03A8:  GOTO   3D1
03A9:  BSF    03.6
03AA:  MOVF   0C,W
03AB:  ANDLW  7F
03AC:  BCF    03.6
03AD:  MOVWF  47
03AE:  BSF    03.6
03AF:  MOVF   0D,W
03B0:  BCF    03.6
03B1:  MOVWF  48
03B2:  BSF    03.6
03B3:  MOVF   0F,W
03B4:  BCF    03.6
03B5:  MOVWF  49
03B6:  MOVF   47,W
03B7:  MOVWF  4F
03B8:  CALL   19A
03B9:  MOVF   48,W
03BA:  BSF    03.6
03BB:  MOVWF  0D
03BC:  BCF    03.6
03BD:  MOVF   49,W
03BE:  BSF    03.6
03BF:  MOVWF  0F
03C0:  BCF    03.6
03C1:  MOVF   0B,W
03C2:  MOVWF  4A
03C3:  BCF    0B.7
03C4:  BSF    03.5
03C5:  BSF    03.6
03C6:  BSF    0C.7
03C7:  BSF    0C.0
03C8:  NOP
03C9:  NOP
03CA:  BCF    03.5
03CB:  BCF    03.6
03CC:  BTFSC  4A.7
03CD:  BSF    0B.7
03CE:  DECFSZ 46,F
03CF:  GOTO   3D1
03D0:  GOTO   3F0
03D1:  BSF    03.6
03D2:  RLF    0C,W
03D3:  RLF    0E,W
03D4:  ANDLW  7F
03D5:  BCF    03.6
03D6:  MOVWF  47
03D7:  BSF    03.6
03D8:  MOVF   0D,W
03D9:  BCF    03.6
03DA:  MOVWF  48
03DB:  BSF    03.6
03DC:  MOVF   0F,W
03DD:  BCF    03.6
03DE:  MOVWF  49
03DF:  MOVF   47,W
03E0:  MOVWF  4F
03E1:  CALL   19A
03E2:  MOVF   48,W
03E3:  BSF    03.6
03E4:  MOVWF  0D
03E5:  BCF    03.6
03E6:  MOVF   49,W
03E7:  BSF    03.6
03E8:  MOVWF  0F
03E9:  INCF   0D,F
03EA:  BTFSC  03.2
03EB:  INCF   0F,F
03EC:  BCF    03.0
03ED:  BCF    03.6
03EE:  DECFSZ 46,F
03EF:  GOTO   39A
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=20000000) 
*
0079:  MOVLW  4C
007A:  MOVWF  04
007B:  BCF    03.7
007C:  MOVF   00,W
007D:  BTFSC  03.2
007E:  GOTO   08C
007F:  MOVLW  06
0080:  MOVWF  78
0081:  CLRF   77
0082:  DECFSZ 77,F
0083:  GOTO   082
0084:  DECFSZ 78,F
0085:  GOTO   081
0086:  MOVLW  7B
0087:  MOVWF  77
0088:  DECFSZ 77,F
0089:  GOTO   088
008A:  DECFSZ 00,F
008B:  GOTO   07F
008C:  RETURN
....................  
.................... void SetupCommunication() { 
....................    set_tris_a(0xff); 
*
001D:  MOVLW  FF
001E:  BSF    03.5
001F:  MOVWF  05
....................    set_tris_d(0x00); 
0020:  MOVLW  00
0021:  MOVWF  08
....................    set_tris_e(0x00); 
0022:  BCF    09.0
0023:  BCF    09.1
0024:  BCF    09.2
....................    set_TRIS_B (0b11011011); // pinos RS e RB2(CS CAB) como saída 
0025:  MOVLW  DB
0026:  MOVWF  06
....................    set_TRIS_C (0b10010111); // RC6 como saida (TX232) RC3 e RC5 (SCK e SO CAN) 
0027:  MOVLW  97
0028:  MOVWF  07
0029:  BCF    03.5
002A:  MOVWF  20
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_16); // Configura a comunicação SPI como Master, com uma atuação na borda de subida e com uma divisão de 16 no clock 
002B:  BCF    14.5
002C:  BCF    20.5
002D:  MOVF   20,W
002E:  BSF    03.5
002F:  MOVWF  07
0030:  BCF    03.5
0031:  BSF    20.4
0032:  MOVF   20,W
0033:  BSF    03.5
0034:  MOVWF  07
0035:  BCF    03.5
0036:  BCF    20.3
0037:  MOVF   20,W
0038:  BSF    03.5
0039:  MOVWF  07
003A:  MOVLW  21
003B:  BCF    03.5
003C:  MOVWF  14
003D:  MOVLW  40
003E:  BSF    03.5
003F:  MOVWF  14
....................    enable_interrupts(global|int_timer0); // Habilita interrupções 
0040:  MOVLW  E0
0041:  BCF    03.5
0042:  IORWF  0B,F
0043:  BCF    0A.3
0044:  BCF    0A.4
0045:  GOTO   432 (RETURN)
.................... } 
....................  
.................... void SetupTimers() { 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32); // Define timer 0 
.................... } 
....................  
....................  
.................... #include "lcd.h" 
.................... #include <regs_16f87x.h> 
.................... #include "regs_16.h" 
.................... // Este arquivo contém as definições dos registradores SFR comuns a série 16 
....................  
.................... #BYTE INDF		= 0x00 
.................... #BYTE TMR0		= 0x01 
.................... #BYTE PCL		= 0x02 
.................... #BYTE STATUS		= 0x03 
.................... 	#BIT IRP	= STATUS.7 
.................... 	#BIT RP1	= STATUS.6 
.................... 	#BIT RP0	= STATUS.5 
.................... 	#BIT TO		= STATUS.4 
.................... 	#BIT PD		= STATUS.3 
.................... 	#BIT Z		= STATUS.2 
.................... 	#BIT DC		= STATUS.1 
.................... 	#BIT C		= STATUS.0 
.................... #BYTE FSR		= 0x04 
.................... #BYTE PORTA		= 0x05 
.................... #BYTE PORTB		= 0x06 
.................... #BYTE PORTC		= 0x07 
.................... #BYTE PORTD		= 0x08 
.................... #BYTE PORTE		= 0x09 
.................... #BYTE PCLATH		= 0x0A 
.................... #BYTE INTCON		= 0x0B 
.................... 	#BIT GIE	= INTCON.7 
.................... 	#BIT PEIE	= INTCON.6 
.................... 	#BIT TMR0IE 	= INTCON.5 
.................... 	#BIT T0IE	= INTCON.5 
.................... 	#BIT INTE	= INTCON.4 
.................... 	#BIT RBIE	= INTCON.3 
.................... 	#BIT TMR0IF 	= INTCON.2 
.................... 	#BIT T0IF	= INTCON.2 
.................... 	#BIT INTF	= INTCON.1 
.................... 	#BIT RBIF	= INTCON.0 
.................... #BYTE PIR1		= 0x0C 
.................... #BYTE PIR2		= 0x0D 
.................... #BYTE TMR1L		= 0x0E 
.................... #BYTE TMR1H		= 0x0F 
.................... #BYTE T1CON		= 0x10 
.................... 	#BIT T1CKPS1	= T1CON.5 
.................... 	#BIT T1CKPS0	= T1CON.4 
.................... 	#BIT T1OSCEN	= T1CON.3 
.................... 	#BIT T1SYNC	= T1CON.2 
.................... 	#BIT TMR1CS	= T1CON.1 
.................... 	#BIT TMR1ON	= T1CON.0 
.................... #BYTE TMR2		= 0x11 
.................... #BYTE T2CON		= 0x12 
.................... 	#BIT TOUTPS3	= T2CON.6 
.................... 	#BIT TOUTPS2	= T2CON.5 
.................... 	#BIT TOUTPS1	= T2CON.4 
.................... 	#BIT TOUTPS0	= T2CON.3 
.................... 	#BIT TMR2ON	= T2CON.2 
.................... 	#BIT T2CKPS1	= T2CON.1 
.................... 	#BIT T2CKPS0	= T2CON.0 
.................... #BYTE CCPR1L		= 0x15 
.................... #BYTE CCPR1H		= 0x16 
.................... #BYTE CCP1CON		= 0x17 
.................... 	#BIT CCP1X	= CCP1CON.5 
.................... 	#BIT CCP1Y	= CCP1CON.4 
.................... 	#BIT CCP1M3	= CCP1CON.3 
.................... 	#BIT CCP1M2	= CCP1CON.2 
.................... 	#BIT CCP1M1	= CCP1CON.1 
.................... 	#BIT CCP1M0	= CCP1CON.0 
.................... #BYTE CCPR2L		= 0x1B 
.................... #BYTE CCPR2H		= 0x1C 
.................... #BYTE CCP2CON		= 0x1D 
.................... 	#BIT CCP2X	= CCP2CON.5 
.................... 	#BIT CCP2Y	= CCP2CON.4 
.................... 	#BIT CCP2M3	= CCP2CON.3 
.................... 	#BIT CCP2M2	= CCP2CON.2 
.................... 	#BIT CCP2M1	= CCP2CON.1 
.................... 	#BIT CCP2M0	= CCP2CON.0 
.................... #BYTE OPTION		= 0x81 
.................... 	#BIT RBPU	= OPTION.7 
.................... 	#BIT INTEDG 	= OPTION.6 
.................... 	#BIT T0CS	= OPTION.5 
.................... 	#BIT T0SE	= OPTION.4 
.................... 	#BIT PSA	= OPTION.3 
.................... 	#BIT PS2	= OPTION.2 
.................... 	#BIT PS1	= OPTION.1 
.................... 	#BIT PS0	= OPTION.0 
.................... #BYTE TRISA		= 0x85 
.................... #BYTE TRISB		= 0x86 
.................... #BYTE TRISC		= 0x87 
.................... #BYTE TRISD		= 0x88 
.................... #BYTE TRISE		= 0x89 
.................... 	#BIT IBF	= TRISE.7 
.................... 	#BIT OBF	= TRISE.6 
.................... 	#BIT IBOV	= TRISE.5 
.................... 	#BIT PSPMODE	= TRISE.4 
.................... #BYTE PCON		= 0x8E 
.................... 	#BIT OSCF	= PCON.3 
.................... 	#BIT POR	= PCON.1 
.................... 	#BIT BOD	= PCON.0 
.................... #BYTE PIE1		= 0x8C 
.................... #BYTE PIE2		= 0x8D 
.................... #BYTE OSCCAL		= 0x90 
.................... #BYTE PR2		= 0x92 
.................... #BYTE WPU		= 0x95 
.................... #BYTE IOCB		= 0x96 
....................  
....................  
.................... // definições válidas para os PICs da série 16F87x e 16F87xA 
.................... // Autor: Fábio Pereira 
....................  
.................... // PIR1 
.................... 	#BIT PSPIF	= PIR1.7 
.................... 	#BIT ADIF	= PIR1.6 
.................... 	#BIT RCIF	= PIR1.5 
.................... 	#BIT TXIF	= PIR1.4 
.................... 	#BIT SSPIF	= PIR1.3 
.................... 	#BIT CCP1IF	= PIR1.2 
.................... 	#BIT TMR2IF	= PIR1.1 
.................... 	#BIT TMR1IF	= PIR1.0 
.................... // PIR2 
.................... 	#BIT CMIF	= PIR2.6 
.................... 	#BIT EEIF	= PIR2.4 
.................... 	#BIT BCLIF	= PIR2.3 
.................... 	#BIT CCP2IF	= PIR2.0 
.................... #BYTE SSPBUF		= 0x13 
.................... #BYTE SSPCON		= 0x14 
.................... 	#BIT WCOL	= SSPCON.7 
.................... 	#BIT SSPOV	= SSPCON.6 
.................... 	#BIT SSPEN	= SSPCON.5 
.................... 	#BIT CKP	= SSPCON.4 
.................... 	#BIT SSPM3	= SSPCON.3 
.................... 	#BIT SSPM2	= SSPCON.2 
.................... 	#BIT SSPM1	= SSPCON.1 
.................... 	#BIT SSPM0	= SSPCON.0 
.................... #BYTE RCSTA		= 0x18 
.................... 	#BIT SPEN	= RCSTA.7 
.................... 	#BIT RX9	= RCSTA.6 
.................... 	#BIT SREN	= RCSTA.5 
.................... 	#BIT CREN	= RCSTA.4 
.................... 	#BIT ADDEN	= RCSTA.3 
.................... 	#BIT FERR	= RCSTA.2 
.................... 	#BIT OERR	= RCSTA.1 
.................... 	#BIT RX9D	= RCSTA.0 
.................... #BYTE TXREG		= 0x19 
.................... #BYTE RCREG		= 0x1A 
.................... #BYTE ADRESH		= 0x1E 
.................... #BYTE ADCON0		= 0x1F 
.................... 	#BIT ADCS1	= ADCON0.7 
.................... 	#BIT ADCS0	= ADCON0.6 
.................... 	#BIT CHS2	= ADCON0.5 
.................... 	#BIT CHS1	= ADCON0.4 
.................... 	#BIT CHS0	= ADCON0.3 
.................... 	#BIT GO_DONE	= ADCON0.2 
.................... 	#BIT ADON	= ADCON0.0 
.................... // PIE1 
.................... 	#BIT PSPIE	= PIE1.7 
.................... 	#BIT ADIE	= PIE1.6 
.................... 	#BIT RCIE	= PIE1.5 
.................... 	#BIT TXIE	= PIE1.4 
.................... 	#BIT SSPIE	= PIE1.3 
.................... 	#BIT CCP1IE	= PIE1.2 
.................... 	#BIT TMR2IE	= PIE1.1 
.................... 	#BIT TMR1IE	= PIE1.0 
.................... // PIE2 
.................... 	#BIT CMIE	= PIE2.6 
.................... 	#BIT EEIE	= PIE2.4 
.................... 	#BIT BCLIE	= PIE2.3 
.................... 	#BIT CCP2IE	= PIE2.0 
.................... #BYTE SSPCON2		= 0x91 
.................... 	#BIT GCEN	= SSPCON2.7 
.................... 	#BIT ACKSTAT	= SSPCON2.6 
.................... 	#BIT ACKDT	= SSPCON2.5 
.................... 	#BIT ACKEN	= SSPCON2.4 
.................... 	#BIT RCEN	= SSPCON2.3 
.................... 	#BIT PEN	= SSPCON2.2 
.................... 	#BIT RSEN	= SSPCON2.1 
.................... 	#BIT SEN	= SSPCON2.0 
.................... #BYTE SSPADD		= 0x93 
.................... #BYTE SSPSTAT		= 0x94 
.................... 	#BIT SMP	= SSPSTAT.7 
.................... 	#BIT CKE	= SSPSTAT.6 
.................... 	#BIT D_A	= SSPSTAT.5 
.................... 	#BIT P		= SSPSTAT.4 
.................... 	#BIT S		= SSPSTAT.3 
.................... 	#BIT R_W	= SSPSTAT.2 
.................... 	#BIT UA		= SSPSTAT.1 
.................... 	#BIT BF		= SSPSTAT.0 
.................... #BYTE TXSTA		= 0x98 
.................... 	#BIT CSRC	= TXSTA.7 
.................... 	#BIT TX9	= TXSTA.6 
.................... 	#BIT TXEN	= TXSTA.5 
.................... 	#BIT SYNC	= TXSTA.4 
.................... 	#BIT BRGH	= TXSTA.2 
.................... 	#BIT TRMT	= TXSTA.1 
.................... 	#BIT TX9D	= TXSTA.0 
.................... #BYTE SPBRG		= 0x99 
.................... #BYTE CMCON		= 0x9C 
.................... //	#BIT C2OUT	= CMCON.7	// Já definido nos arquivos pic16f87xa.h 
.................... //	#BIT C1OUT	= CMCON.6	// Já definido nos arquivos pic16f87xa.h 
.................... 	#BIT C2INV	= CMCON.5 
.................... 	#BIT C1INV	= CMCON.4 
.................... 	#BIT CIS	= CMCON.3 
.................... 	#BIT CM2	= CMCON.2 
.................... 	#BIT CM1	= CMCON.1 
.................... 	#BIT CM0	= CMCON.0 
.................... #BYTE CVRCON		= 0x9D 
.................... 	#BIT CVREN	= CVRCON.7 
.................... 	#BIT CVROE	= CVRCON.6 
.................... 	#BIT CVRR	= CVRCON.5 
.................... 	#BIT CVR3	= CVRCON.3 
.................... 	#BIT CVR2	= CVRCON.2 
.................... 	#BIT CVR1	= CVRCON.1 
.................... 	#BIT CVR0	= CVRCON.0 
.................... #BYTE ADRESL		= 0x9E 
.................... #BYTE ADCON1		= 0x9F 
.................... 	#BIT ADFM	= ADCON1.7 
.................... 	#BIT ADCS2	= ADCON1.6 
.................... 	#BIT PCFG3	= ADCON1.3 
.................... 	#BIT PCFG2	= ADCON1.2 
.................... 	#BIT PCFG1	= ADCON1.1 
.................... 	#BIT PCFG0	= ADCON1.0 
.................... #BYTE EEDATA		= 0x10C 
.................... #BYTE EEADR		= 0x10D 
.................... #BYTE EEDATH		= 0x10E 
.................... #BYTE EEADRH		= 0x10F 
.................... #BYTE EECON1		= 0x18C 
.................... 	#BIT EEPGD	= EECON1.7 
.................... 	#BIT WRERR	= EECON1.3 
.................... 	#BIT WREN	= EECON1.2 
.................... 	#BIT WR		= EECON1.1 
.................... 	#BIT RD		= EECON1.0 
.................... #BYTE EECON2		= 0x18D 
....................  
....................  
.................... #define LINE0_ADDRESS 0X80 
.................... #define LINE1_ADDRESS 0XAF 
....................  
....................   // ENTRADAS                               * 
.................... // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... // As entradas devem ser associadas a nomes para facilitar a programação e 
.................... // futuras alterações do hardware. 
.................... #bit  C1   = portd.0                     // definições das chaves 
.................... #bit  C2   = portd.1                     // chave aberta  = 1 
.................... #bit  C3   = portd.2                     // chave fechada = 0 
.................... #bit  C4   = portd.3 
....................  
.................... ///* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 
.................... // *                               SAÍDAS                                * 
.................... // * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 
.................... // As saídas devem ser associadas a nomes para facilitar a programação e 
.................... // futuras alterações do hardware. 
.................... #bit  RS          = portb.5 
.................... #bit  E           = portd.4 
.................... #bit  DATA_PIN_7  = portd.3 
.................... #bit  DATA_PIN_6  = portd.2 
.................... #bit  DATA_PIN_5  = portd.1 
.................... #bit  DATA_PIN_4  = portd.0 
....................  
.................... //********************* LOW LEVEL FUNCTIONS ********************* 
....................  
.................... void LcdCommand(char data) { 
....................    RS = 0;                  // seleciona o envio de um comando 
*
00DD:  BCF    06.5
....................  
....................    TRISD = TRISD & 0xF0;      // configura pinos D0..D3 como saídas 
00DE:  MOVLW  F0
00DF:  BSF    03.5
00E0:  ANDWF  08,F
....................  
....................    DATA_PIN_7 = (unsigned char)((data & 0x80)>>7);   //acerta dado 
00E1:  BCF    03.5
00E2:  MOVF   48,W
00E3:  ANDLW  80
00E4:  MOVWF  77
00E5:  RLF    77,W
00E6:  CLRF   77
00E7:  BTFSC  03.0
00E8:  BSF    77.0
00E9:  BTFSS  77.0
00EA:  BCF    08.3
00EB:  BTFSC  77.0
00EC:  BSF    08.3
....................    DATA_PIN_6 = (unsigned char)((data & 0x40)>>6);   //no barramento 
00ED:  MOVF   48,W
00EE:  ANDLW  40
00EF:  MOVWF  77
00F0:  SWAPF  77,F
00F1:  RRF    77,F
00F2:  RRF    77,F
00F3:  MOVLW  03
00F4:  ANDWF  77,F
00F5:  BTFSS  77.0
00F6:  BCF    08.2
00F7:  BTFSC  77.0
00F8:  BSF    08.2
....................    DATA_PIN_5 = (unsigned char)((data & 0x20)>>5); 
00F9:  MOVF   48,W
00FA:  ANDLW  20
00FB:  MOVWF  77
00FC:  SWAPF  77,F
00FD:  RRF    77,F
00FE:  MOVLW  07
00FF:  ANDWF  77,F
0100:  BTFSS  77.0
0101:  BCF    08.1
0102:  BTFSC  77.0
0103:  BSF    08.1
....................    DATA_PIN_4 = (unsigned char)((data & 0x10)>>4); 
0104:  MOVF   48,W
0105:  ANDLW  10
0106:  MOVWF  77
0107:  SWAPF  77,F
0108:  MOVLW  0F
0109:  ANDWF  77,F
010A:  BTFSS  77.0
010B:  BCF    08.0
010C:  BTFSC  77.0
010D:  BSF    08.0
....................     
....................    E = 1;                  // envia pulso de enable 
010E:  BSF    08.4
....................    delay_us(1); 
010F:  GOTO   110
0110:  GOTO   111
0111:  NOP
....................    E = 0; 
0112:  BCF    08.4
....................     
....................    DATA_PIN_7 = (unsigned char)((data & 0x08)>>3);   // acerta dado 
0113:  MOVF   48,W
0114:  ANDLW  08
0115:  MOVWF  77
0116:  RRF    77,F
0117:  RRF    77,F
0118:  RRF    77,F
0119:  MOVLW  1F
011A:  ANDWF  77,F
011B:  BTFSS  77.0
011C:  BCF    08.3
011D:  BTFSC  77.0
011E:  BSF    08.3
....................    DATA_PIN_6 = (unsigned char)((data & 0x04)>>2);   // no barramento 
011F:  MOVF   48,W
0120:  ANDLW  04
0121:  MOVWF  77
0122:  RRF    77,F
0123:  RRF    77,F
0124:  MOVLW  3F
0125:  ANDWF  77,F
0126:  BTFSS  77.0
0127:  BCF    08.2
0128:  BTFSC  77.0
0129:  BSF    08.2
....................    DATA_PIN_5 = (unsigned char)((data & 0x02)>>1); 
012A:  MOVF   48,W
012B:  ANDLW  02
012C:  MOVWF  77
012D:  BCF    03.0
012E:  RRF    77,F
012F:  BTFSS  77.0
0130:  BCF    08.1
0131:  BTFSC  77.0
0132:  BSF    08.1
....................    DATA_PIN_4 = (unsigned char)(data & 0x01); 
0133:  MOVF   48,W
0134:  ANDLW  01
0135:  MOVWF  78
0136:  BTFSS  78.0
0137:  BCF    08.0
0138:  BTFSC  78.0
0139:  BSF    08.0
....................     
....................    E = 1;                  // envia pulso de enable 
013A:  BSF    08.4
....................    delay_us(1); 
013B:  GOTO   13C
013C:  GOTO   13D
013D:  NOP
....................    E = 0; 
013E:  BCF    08.4
....................     
....................    delay_us(40); 
013F:  MOVLW  42
0140:  MOVWF  77
0141:  DECFSZ 77,F
0142:  GOTO   141
0143:  NOP
....................    TRISD = TRISD | 0x0F;      // configura pinos D0..D3 como entradas 
0144:  MOVLW  0F
0145:  BSF    03.5
0146:  IORWF  08,F
0147:  BCF    03.5
0148:  RETURN
.................... } 
....................  
.................... void LcdClear(void) { 
....................    LcdCommand(0x01);         // limpa lcd 
*
017D:  MOVLW  01
017E:  MOVWF  48
017F:  CALL   0DD
....................    delay_ms(2); 
0180:  MOVLW  02
0181:  MOVWF  4C
0182:  CALL   079
.................... } 
....................  
.................... void LcdInitialize(void) { 
....................    delay_ms(100);            // espera 100 milisengundos 
*
0149:  MOVLW  64
014A:  MOVWF  4C
014B:  CALL   079
....................    TRISD = TRISD & 0xE0;      // configura pinos D0..D3 como saídas 
014C:  MOVLW  E0
014D:  BSF    03.5
014E:  ANDWF  08,F
....................     
....................    PORTD = 0x03; 
014F:  MOVLW  03
0150:  BCF    03.5
0151:  MOVWF  08
....................    
....................    E = 1 ;                    // gera pulso no enable 
0152:  BSF    08.4
....................    delay_us(1);            // espera 1 microsegundo 
0153:  GOTO   154
0154:  GOTO   155
0155:  NOP
....................    E = 0;                    // desce o pino de enable 
0156:  BCF    08.4
....................     
....................    delay_ms(5);            // espera 5 milisengundos 
0157:  MOVLW  05
0158:  MOVWF  4C
0159:  CALL   079
....................     
....................    E = 1 ;                  // gera pulso no enable 
015A:  BSF    08.4
....................    delay_us(1);            // espera 1 microsegundo 
015B:  GOTO   15C
015C:  GOTO   15D
015D:  NOP
....................    E = 0;                  // desce o pino de enable 
015E:  BCF    08.4
....................     
....................    delay_us(100);            // espera 100 microsengundos 
015F:  MOVLW  A6
0160:  MOVWF  77
0161:  DECFSZ 77,F
0162:  GOTO   161
0163:  NOP
....................     
....................    E = 1 ;                  // gera pulso no enable 
0164:  BSF    08.4
....................    delay_us(1);            // espera 1 microsegundo 
0165:  GOTO   166
0166:  GOTO   167
0167:  NOP
....................    E = 0;                  // desce o pino de enable 
0168:  BCF    08.4
....................     
....................    delay_us(40);            // espera 40 microsegundos 
0169:  MOVLW  42
016A:  MOVWF  77
016B:  DECFSZ 77,F
016C:  GOTO   16B
016D:  NOP
....................     
....................    PORTD = 0x02; 
016E:  MOVLW  02
016F:  MOVWF  08
....................     
....................    E = 1 ;                  // gera pulso no enable 
0170:  BSF    08.4
....................    delay_us(1);            // espera 1 microsegundo 
0171:  GOTO   172
0172:  GOTO   173
0173:  NOP
....................    E = 0;                  // desce o pino de enable 
0174:  BCF    08.4
....................     
....................    delay_us(40);            // espera 40 microsegundos 
0175:  MOVLW  42
0176:  MOVWF  77
0177:  DECFSZ 77,F
0178:  GOTO   177
0179:  NOP
....................     
....................    LcdCommand(0x28);         // liga o display, sem cursor e sem blink (4 vias) 
017A:  MOVLW  28
017B:  MOVWF  48
017C:  CALL   0DD
....................     
....................    LcdClear();            // limpa lcd 
....................     
....................    LcdCommand(0x0C);         // display sem cursor 
*
0183:  MOVLW  0C
0184:  MOVWF  48
0185:  CALL   0DD
....................     
....................    LcdCommand(0x06);         // desloca cursor para a direita 
0186:  MOVLW  06
0187:  MOVWF  48
0188:  CALL   0DD
0189:  BCF    0A.3
018A:  BCF    0A.4
018B:  GOTO   434 (RETURN)
.................... } 
....................  
.................... void LcdWrite(char data) 
.................... { 
....................    RS = 1;                  // seleciona o envio de um comando 
*
020C:  BSF    06.5
....................     
....................    TRISD = TRISD & 0xF0;      // configura pinos D0..D3 como saídas 
020D:  MOVLW  F0
020E:  BSF    03.5
020F:  ANDWF  08,F
....................     
....................    DATA_PIN_7 = (char)((data & 0x80)>>7);   // acerta dado 
0210:  BCF    03.5
0211:  MOVF   4D,W
0212:  ANDLW  80
0213:  MOVWF  77
0214:  RLF    77,W
0215:  CLRF   77
0216:  BTFSC  03.0
0217:  BSF    77.0
0218:  BTFSS  77.0
0219:  BCF    08.3
021A:  BTFSC  77.0
021B:  BSF    08.3
....................    DATA_PIN_6 = (char)((data & 0x40)>>6);   // no barramento 
021C:  MOVF   4D,W
021D:  ANDLW  40
021E:  MOVWF  77
021F:  SWAPF  77,F
0220:  RRF    77,F
0221:  RRF    77,F
0222:  MOVLW  03
0223:  ANDWF  77,F
0224:  BTFSS  77.0
0225:  BCF    08.2
0226:  BTFSC  77.0
0227:  BSF    08.2
....................    DATA_PIN_5 = (char)((data & 0x20)>>5); 
0228:  MOVF   4D,W
0229:  ANDLW  20
022A:  MOVWF  77
022B:  SWAPF  77,F
022C:  RRF    77,F
022D:  MOVLW  07
022E:  ANDWF  77,F
022F:  BTFSS  77.0
0230:  BCF    08.1
0231:  BTFSC  77.0
0232:  BSF    08.1
....................    DATA_PIN_4 = (char)((data & 0x10)>>4); 
0233:  MOVF   4D,W
0234:  ANDLW  10
0235:  MOVWF  77
0236:  SWAPF  77,F
0237:  MOVLW  0F
0238:  ANDWF  77,F
0239:  BTFSS  77.0
023A:  BCF    08.0
023B:  BTFSC  77.0
023C:  BSF    08.0
....................     
....................    E = 1;            // envia pulso de enable 
023D:  BSF    08.4
....................    delay_us(1); 
023E:  GOTO   23F
023F:  GOTO   240
0240:  NOP
....................    E = 0; 
0241:  BCF    08.4
....................     
....................    DATA_PIN_7 = (char)((data & 0x08)>>3);   // acerta dado 
0242:  MOVF   4D,W
0243:  ANDLW  08
0244:  MOVWF  77
0245:  RRF    77,F
0246:  RRF    77,F
0247:  RRF    77,F
0248:  MOVLW  1F
0249:  ANDWF  77,F
024A:  BTFSS  77.0
024B:  BCF    08.3
024C:  BTFSC  77.0
024D:  BSF    08.3
....................    DATA_PIN_6 = (char)((data & 0x04)>>2);   // no barramento 
024E:  MOVF   4D,W
024F:  ANDLW  04
0250:  MOVWF  77
0251:  RRF    77,F
0252:  RRF    77,F
0253:  MOVLW  3F
0254:  ANDWF  77,F
0255:  BTFSS  77.0
0256:  BCF    08.2
0257:  BTFSC  77.0
0258:  BSF    08.2
....................    DATA_PIN_5 = (char)((data & 0x02)>>1); 
0259:  MOVF   4D,W
025A:  ANDLW  02
025B:  MOVWF  77
025C:  BCF    03.0
025D:  RRF    77,F
025E:  BTFSS  77.0
025F:  BCF    08.1
0260:  BTFSC  77.0
0261:  BSF    08.1
....................    DATA_PIN_4 = (char)(data & 0x01); 
0262:  MOVF   4D,W
0263:  ANDLW  01
0264:  MOVWF  78
0265:  BTFSS  78.0
0266:  BCF    08.0
0267:  BTFSC  78.0
0268:  BSF    08.0
....................     
....................    E = 1;            // envia pulso de enable 
0269:  BSF    08.4
....................    delay_us(1); 
026A:  GOTO   26B
026B:  GOTO   26C
026C:  NOP
....................    E = 0; 
026D:  BCF    08.4
....................     
....................    delay_us(40); 
026E:  MOVLW  42
026F:  MOVWF  77
0270:  DECFSZ 77,F
0271:  GOTO   270
0272:  NOP
....................    TRISD = TRISD | 0x0F;      // configura pinos D0..D3 como entradas 
0273:  MOVLW  0F
0274:  BSF    03.5
0275:  IORWF  08,F
.................... } 
....................  
.................... //********************* HIGH LEVEL FUNCTIONS ********************* 
....................  
.................... void WriteLCD(char* msg, int length) { 
....................    for(int i = 0; i < length; i++) { 
*
01FD:  CLRF   4B
01FE:  MOVF   4A,W
01FF:  SUBWF  4B,W
0200:  BTFSC  03.0
0201:  GOTO   27C
....................       LcdWrite(msg[i]); 
0202:  MOVF   4B,W
0203:  ADDWF  48,W
0204:  MOVWF  04
0205:  BCF    03.7
0206:  BTFSC  49.0
0207:  BSF    03.7
0208:  MOVF   00,W
0209:  MOVWF  4C
020A:  MOVF   4C,W
020B:  MOVWF  4D
....................       delay_ms(5); 
*
0276:  MOVLW  05
0277:  BCF    03.5
0278:  MOVWF  4C
0279:  CALL   079
027A:  INCF   4B,F
027B:  GOTO   1FE
....................    } 
027C:  RETURN
.................... } 
....................  
.................... void WriteLCDLine0(char* line) { 
....................    LcdCommand(LINE0_ADDRESS); 
027D:  MOVLW  80
027E:  MOVWF  48
027F:  CALL   0DD
....................    WriteLCD(line, 16); 
0280:  MOVF   43,W
0281:  MOVWF  49
0282:  MOVF   42,W
0283:  MOVWF  48
0284:  MOVLW  10
0285:  MOVWF  4A
0286:  CALL   1FD
0287:  RETURN
.................... } 
....................  
.................... void WriteLCDLine1(char* line) { 
....................    LcdCommand(LINE1_ADDRESS); 
*
0404:  MOVLW  AF
0405:  MOVWF  48
0406:  CALL   0DD
....................    WriteLCD(line, 16); 
0407:  MOVF   47,W
0408:  MOVWF  49
0409:  MOVF   46,W
040A:  MOVWF  48
040B:  MOVLW  10
040C:  MOVWF  4A
040D:  CALL   1FD
.................... } 
....................  
.................... char lcdBuffer[16]; 
....................  
.................... void ClearLCDBuffer() { 
....................    for (int i = 0; i < 16; i++) { 
*
018C:  CLRF   46
018D:  MOVF   46,W
018E:  SUBLW  0F
018F:  BTFSS  03.0
0190:  GOTO   199
....................       lcdBuffer[i] = ' '; 
0191:  MOVLW  21
0192:  ADDWF  46,W
0193:  MOVWF  04
0194:  BCF    03.7
0195:  MOVLW  20
0196:  MOVWF  00
0197:  INCF   46,F
0198:  GOTO   18D
....................    } 
0199:  RETURN
.................... } 
....................  
....................  
.................... #include <can-communication.h> 
.................... #include <can_mcp2515.h> 
.................... typedef unsigned long int Can_Id; 
....................  
.................... //******************** BASE ROUTINES ******************** 
....................  
.................... int CanKbhit(void) { 
....................    int teste; 
....................    output_high (PIN_B2); // Configuração do Chip Select 
....................    output_low(PIN_B2); // Configuração do Chip Select 
....................    output_high (PIN_B2); // Configuração do Chip Select 
....................    delay_us (10); 
....................    output_low(PIN_B2); // Configuração do Chip Select 
....................    spi_write(0b00000011); // Manda a instrução de leitura para o transceiver 
....................    spi_write(0x2C); // Envia o endereço no qual deseja receber a informação 
....................    teste = spi_read(0); //informa se chegou um dado no receptor, registrador CANINTF 
....................    output_high(PIN_B2); 
....................    delay_us (10); 
....................    return teste&0x01; 
.................... } 
....................  
.................... void CanWrite (int end, int dado) { 
....................    output_high (PIN_B2); // Configuração do Chip Select 
*
0046:  BSF    03.5
0047:  BCF    06.2
0048:  BCF    03.5
0049:  BSF    06.2
....................    output_low(PIN_B2); // Configuração do Chip Select 
004A:  BSF    03.5
004B:  BCF    06.2
004C:  BCF    03.5
004D:  BCF    06.2
....................    output_high(PIN_B2); // Configuração do Chip Select 
004E:  BSF    03.5
004F:  BCF    06.2
0050:  BCF    03.5
0051:  BSF    06.2
....................    delay_us (10); 
0052:  MOVLW  10
0053:  MOVWF  77
0054:  DECFSZ 77,F
0055:  GOTO   054
0056:  NOP
....................    output_low(PIN_B2); // Configuração do Chip Select 
0057:  BSF    03.5
0058:  BCF    06.2
0059:  BCF    03.5
005A:  BCF    06.2
....................    spi_write(0b00000010); // Manda a instrução de escrita para o transceiver 
005B:  MOVF   13,W
005C:  MOVLW  02
005D:  MOVWF  13
005E:  BSF    03.5
005F:  RRF    14,W
0060:  BTFSS  03.0
0061:  GOTO   05F
....................    spi_write(end); // Envia o endereço no qual se deseja guardar o dado 
0062:  BCF    03.5
0063:  MOVF   47,W
0064:  MOVWF  13
0065:  BSF    03.5
0066:  RRF    14,W
0067:  BTFSS  03.0
0068:  GOTO   066
....................    spi_write(dado); // Envia o dado 
0069:  BCF    03.5
006A:  MOVF   48,W
006B:  MOVWF  13
006C:  BSF    03.5
006D:  RRF    14,W
006E:  BTFSS  03.0
006F:  GOTO   06D
....................    output_high(PIN_B2); // Configuração do Chip Select 
0070:  BCF    06.2
0071:  BCF    03.5
0072:  BSF    06.2
....................    delay_us (10); 
0073:  MOVLW  10
0074:  MOVWF  77
0075:  DECFSZ 77,F
0076:  GOTO   075
0077:  NOP
0078:  RETURN
.................... } 
....................  
.................... void CanFilter (Can_Id id) { 
....................  
....................    CanWrite (0x0F, 0b10000000); // CANCTRL, coloca em modo de configuração 
....................  
....................    int mask_on = 0; 
....................    if (id == 0) mask_on |= 0b01100000; 
....................  
....................    //Setar filtros 
....................    CanWrite(0x60, 0b00000000 | mask_on); 
....................    CanWrite(0x70, 0b00000000 | mask_on); 
....................     
....................     //Mascaras em 1 
....................    CanWrite(0x20, 0xFF); 
....................    //CanWrite(0x21, 0xFF); 
....................     
....................    unsigned char IDR0_filter = 0; // Contem a mascara para o registrador IDR0 
....................    unsigned char IDR1_filter = 0; // Contem a mascara para o registrador IDR1 
....................    IDR0_filter |= (unsigned char)((id >> 3) & 0xFF); // ID10 a ID3 
....................    IDR1_filter |= (unsigned char)((id & 0b0000000000000111) << 5); // ID2 a ID0 + (IDE = 0) 
....................     
....................    //Filtrar mensagem desejada 
....................    CanWrite(0x00, IDR0_filter); 
....................    CanWrite(0x01, IDR1_filter); 
....................     
....................    CanWrite (0x0F, 0x00); // CANCTRL, coloca em modo de trabalho 
.................... } 
....................  
.................... void CanReset(void) { 
....................    output_high (PIN_B2); // Configuração do Chip Select 
*
008D:  BSF    03.5
008E:  BCF    06.2
008F:  BCF    03.5
0090:  BSF    06.2
....................    output_low(PIN_B2); // Configuração do Chip Select 
0091:  BSF    03.5
0092:  BCF    06.2
0093:  BCF    03.5
0094:  BCF    06.2
....................    output_high(PIN_B2); // Configuração do Chip Select 
0095:  BSF    03.5
0096:  BCF    06.2
0097:  BCF    03.5
0098:  BSF    06.2
....................    delay_us (10); 
0099:  MOVLW  10
009A:  MOVWF  77
009B:  DECFSZ 77,F
009C:  GOTO   09B
009D:  NOP
....................    output_low(PIN_B2); // Configuração do Chip Select 
009E:  BSF    03.5
009F:  BCF    06.2
00A0:  BCF    03.5
00A1:  BCF    06.2
....................    spi_write(0b11000000); 
00A2:  MOVF   13,W
00A3:  MOVLW  C0
00A4:  MOVWF  13
00A5:  BSF    03.5
00A6:  RRF    14,W
00A7:  BTFSS  03.0
00A8:  GOTO   0A6
....................    output_high(PIN_B2); // Configuração do Chip Select 
00A9:  BCF    06.2
00AA:  BCF    03.5
00AB:  BSF    06.2
....................    delay_us (10); 
00AC:  MOVLW  10
00AD:  MOVWF  77
00AE:  DECFSZ 77,F
00AF:  GOTO   0AE
00B0:  NOP
.................... } 
....................                
.................... //******************** RX ROUTINES ******************** 
....................  
.................... int CanRead (int end) { 
....................    int data; 
....................    CanWrite (0x2C, 0x00); // Habilita a leitura novamente zerando o CANINTF 
....................    output_high (PIN_B2); // Configuração do Chip Select 
....................    output_low(PIN_B2); // Configuração do Chip Select 
....................    output_high (PIN_B2); // Configuração do Chip Select 
....................    delay_us (10); 
....................    output_low(PIN_B2); // Configuração do Chip Select 
....................    spi_write(0b00000011); // Manda a instrução de leitura para o transceiver 
....................    spi_write(end); // Envia o endereço no qual deseja receber a informação 
....................    data = spi_read(0); 
....................    output_high (PIN_B2); 
....................    delay_us (10); 
....................    return data; 
.................... } 
....................  
.................... void CanConfig (void) { 
....................    //Configuração do modo de operação 
....................    CanWrite (0x0F, 0b10000000); // CANCTRL, coloca em modo de configuração 
00B1:  MOVLW  0F
00B2:  MOVWF  47
00B3:  MOVLW  80
00B4:  MOVWF  48
00B5:  CALL   046
....................    delay_ms (100); 
00B6:  MOVLW  64
00B7:  MOVWF  4C
00B8:  CALL   079
....................  
....................    //Configuração dos modos de sincronismo 
....................    CanWrite (0x28, 0x02); // CNF3, filtro desabilitado, clock out habilitado, ps2 3 tqs 
00B9:  MOVLW  28
00BA:  MOVWF  47
00BB:  MOVLW  02
00BC:  MOVWF  48
00BD:  CALL   046
....................    CanWrite (0x29, 0xA0); // CNF2, progseg 1tqs, ps5 3 tqs 
00BE:  MOVLW  29
00BF:  MOVWF  47
00C0:  MOVLW  A0
00C1:  MOVWF  48
00C2:  CALL   046
....................    CanWrite (0x2A, 0x01); // CNF1, sjw 1tqs    baud rate 500khz, osc 20mhz ->10tqs 
00C3:  MOVLW  2A
00C4:  MOVWF  47
00C5:  MOVLW  01
00C6:  MOVWF  48
00C7:  CALL   046
....................     
....................    // Interrupções 
....................    CanWrite (0x2B, 0x01); //  interrupção ligada 
00C8:  MOVLW  2B
00C9:  MOVWF  47
00CA:  MOVLW  01
00CB:  MOVWF  48
00CC:  CALL   046
....................    CanWrite (0x2C, 0x00); // Habilita a leitura 
00CD:  MOVLW  2C
00CE:  MOVWF  47
00CF:  CLRF   48
00D0:  CALL   046
....................  
....................    // Modo de funcionamento normal 
....................    CanWrite (0x0F, 0x00); // CANCTRL, coloca em modo de trabalho 
00D1:  MOVLW  0F
00D2:  MOVWF  47
00D3:  CLRF   48
00D4:  CALL   046
....................     
....................    //Seta DLC da Mensagem de Transmissão 8 bytes 
....................    CanWrite (0x35,0x08); 
00D5:  MOVLW  35
00D6:  MOVWF  47
00D7:  MOVLW  08
00D8:  MOVWF  48
00D9:  CALL   046
.................... } 
....................  
.................... //******************** TX ROUTINES ******************** 
....................  
.................... void CanSetSendAddress(unsigned long int address) { 
*
02A0:  RRF    43,W
02A1:  MOVWF  47
02A2:  RRF    42,W
02A3:  MOVWF  46
02A4:  RRF    47,F
02A5:  RRF    46,F
02A6:  RRF    47,F
02A7:  RRF    46,F
02A8:  MOVLW  1F
02A9:  ANDWF  47,F
02AA:  MOVF   46,W
02AB:  MOVWF  77
02AC:  CLRF   7A
02AD:  MOVF   46,W
02AE:  MOVWF  44
02AF:  MOVF   42,W
02B0:  ANDLW  07
02B1:  MOVWF  46
02B2:  CLRF   47
02B3:  RLF    46,W
02B4:  MOVWF  79
02B5:  RLF    47,W
02B6:  MOVWF  7A
02B7:  RLF    79,F
02B8:  RLF    7A,F
02B9:  RLF    79,F
02BA:  RLF    7A,F
02BB:  RLF    79,F
02BC:  RLF    7A,F
02BD:  RLF    79,F
02BE:  RLF    7A,F
02BF:  MOVLW  E0
02C0:  ANDWF  79,F
02C1:  MOVF   79,W
02C2:  MOVWF  45
....................    // Set message id 
....................    int idHigh = (unsigned char)((address >> 3) & 0xFF); 
....................    int idLow = (unsigned char)((address & 0b0000000000000111) << 5); 
....................     
....................    CanWrite(0x31, idHigh); 
02C3:  MOVLW  31
02C4:  MOVWF  47
02C5:  MOVF   44,W
02C6:  MOVWF  48
02C7:  CALL   046
....................    CanWrite(0x32, idLow); 
02C8:  MOVLW  32
02C9:  MOVWF  47
02CA:  MOVF   45,W
02CB:  MOVWF  48
02CC:  CALL   046
02CD:  RETURN
.................... } 
....................  
.................... void CanSend(void) { 
....................    CanWrite (0x30, 0b00001000); // Instrução para enviar a mensagem, TXrequest 
*
02E5:  MOVLW  30
02E6:  MOVWF  47
02E7:  MOVLW  08
02E8:  MOVWF  48
02E9:  CALL   046
....................    CanWrite (0x30, 0b00000000); // Instrução para não enviar mais mensagem 
02EA:  MOVLW  30
02EB:  MOVWF  47
02EC:  CLRF   48
02ED:  CALL   046
....................    CanWrite (0x2C, 0x00); // Habilita a leitura novamente zerando o CANINTF 
02EE:  MOVLW  2C
02EF:  MOVWF  47
02F0:  CLRF   48
02F1:  CALL   046
.................... } 
....................  
.................... //Sends a char[8] message 
.................... void SendCanFrame(char* frame) { 
....................    for (int i = 0; i < 8; i++) { 
*
02CE:  CLRF   44
02CF:  MOVF   44,W
02D0:  SUBLW  07
02D1:  BTFSS  03.0
02D2:  GOTO   2E5
....................       CanWrite(0x36 + i, frame[i]); 
02D3:  MOVLW  36
02D4:  ADDWF  44,W
02D5:  MOVWF  45
02D6:  MOVF   44,W
02D7:  ADDWF  42,W
02D8:  MOVWF  04
02D9:  BCF    03.7
02DA:  BTFSC  43.0
02DB:  BSF    03.7
02DC:  MOVF   00,W
02DD:  MOVWF  46
02DE:  MOVF   45,W
02DF:  MOVWF  47
02E0:  MOVF   46,W
02E1:  MOVWF  48
02E2:  CALL   046
02E3:  INCF   44,F
02E4:  GOTO   2CF
....................    } 
....................    CanSend(); 
*
02F2:  RETURN
.................... } 
....................  
....................  
....................  
.................... typedef struct CAN_MESSAGE { 
....................    char d0; 
....................    char d1; 
....................    char d2; 
....................    char d3; 
....................    char d4; 
....................    char d5; 
....................    char d6; 
....................    char d7; 
.................... } CAN_MESSAGE; 
....................  
.................... typedef struct CAN_590 { 
....................    unsigned long int ref_torque; // ref torque: 0 - 100 %. fator: 0.01 
....................    unsigned long int velocidade; // fator: 0.1 
....................    int marcha; // 0: neutro - 5 
....................    int reserved:2; 
....................    int pedal_freio:1; 
....................    int pedal_embreagem:1; // 1: press, 0: solto 
....................    int modo_cruzeiro:1; 
....................    int modo_pedal_simulado:1; 
....................    int ref_cruzeiro; // fator: 1 
....................    int erro; // 0: sem erro 
.................... } CAN_590; 
....................  
.................... typedef struct CAN_470 { 
....................    int seta_esquerda:1; 
....................    int seta_direita:1; 
....................    int reserved0:1; 
....................    int pisca_alerta:1; 
....................    int reserved1:1; 
....................    int luz_re:1; 
....................    int reserved2:2; 
....................    int porta_motorista:1; 
....................    int porta_passageiro:1; 
....................    int porta_TE:1; 
....................    int porta_TD:1; 
....................    int capo:1; 
....................    int porta_malas:1; 
....................    int reserved3:2; 
....................    int backlight_painel; 
....................    char ignore[5]; 
.................... } CAN_470; 
....................  
.................... typedef struct CAN_SIGNED { 
....................    char e; 
....................    char c; 
....................    char u; 
....................    char reserved[5]; 
.................... } CAN_SIGNED; 
....................  
.................... typedef struct CAN_200 { 
....................    char e; 
....................    char c; 
....................    char u; 
....................    int pedal_simulado; 
....................    char reserved[4]; 
.................... } CAN_200; 
....................  
.................... typedef struct CAN_201 { 
....................    char e; 
....................    char c; 
....................    char u; 
....................    int modo_pedal_sim; // 1: liga, 0: desliga 
....................    int modo_operacao; // 1: econom, 0: normal 
....................    int ref_marcha_lenta; // 0 - 11; 0 = 800, MLenta = 600 + (dado - 1)*50 
.................... } CAN_201; 
....................   
.................... void CanStructInit(CAN_SIGNED* val) { 
....................    val->e = 'E'; 
*
0288:  MOVF   42,W
0289:  MOVWF  04
028A:  BCF    03.7
028B:  BTFSC  43.0
028C:  BSF    03.7
028D:  MOVLW  45
028E:  MOVWF  00
....................    val->c = 'C'; 
028F:  MOVLW  01
0290:  ADDWF  42,W
0291:  MOVWF  04
0292:  BCF    03.7
0293:  BTFSC  43.0
0294:  BSF    03.7
0295:  MOVLW  43
0296:  MOVWF  00
....................    val->u = 'U'; 
0297:  MOVLW  02
0298:  ADDWF  42,W
0299:  MOVWF  04
029A:  BCF    03.7
029B:  BTFSC  43.0
029C:  BSF    03.7
029D:  MOVLW  55
029E:  MOVWF  00
029F:  RETURN
.................... } 
....................  
.................... //Blocking function that reads a single message with a given id. 
.................... #define READ_TIMEOUT 10000 //us 
.................... #define READ_POLLING 100 //us 
.................... #define TIMEOUT_COUNT READ_TIMEOUT / READ_POLLING 
.................... int ReadMessage(Can_Id id, CAN_MESSAGE* buffer, Can_Id *recvId) { 
....................    //Enable hardware filter 
....................    CanFilter(id); 
....................     
....................    //Wait for message 
....................    /*unsigned long timeout = 0; 
....................    while (!CanKbhit() && timeout <= TIMEOUT_COUNT) {   
....................       delay_us(READ_POLLING);  
....................       timeout++; 
....................    }; 
....................     
....................    if (timeout >= TIMEOUT_COUNT) return 0; 
....................    */ 
....................     
....................    if (!CanKbhit()) return 0; 
....................     
....................    //Read 8 bytes 
....................    char temp[8]; 
....................    for (int i = 0; i < 8; i++) { 
....................       temp[i] = CanRead(0x66 + i); 
....................    } 
....................     
....................    //Save read address, if needed 
....................    if (recvId > 0) { 
....................       *recvId = 0; 
....................       *recvId |= (unsigned long)(CanRead(0x61)) << 3; 
....................       *recvId |= (CanRead(0x62) & 0b11100000) >> 5; 
....................    } 
....................     
....................    memcpy(buffer, temp, 8); 
....................     
....................    return 1; 
.................... } 
....................  
.................... void SetupCan() { 
....................    CanReset(); 
....................    CanConfig(); 
*
00DA:  BCF    0A.3
00DB:  BCF    0A.4
00DC:  GOTO   433 (RETURN)
.................... } 
....................  
....................  
....................  
.................... //Prototypes 
.................... void ReadLoop(); 
.................... void WriteLoop(); 
....................  
.................... void PrintNoData() { 
....................    ClearLCDBuffer(); 
....................    sprintf(lcdBuffer, "NO DATA"); 
....................    WriteLCDLine1(&lcdBuffer); 
.................... } 
....................  
.................... void PrintPedal(unsigned long int velocity, Can_ID id) { 
....................    ClearLCDBuffer(); 
*
038D:  CALL   18C
....................    sprintf(lcdBuffer, "PED: %lu|%lu", velocity, id); 
038E:  CLRF   32
038F:  MOVLW  21
0390:  MOVWF  31
0391:  MOVLW  08
0392:  BSF    03.6
0393:  MOVWF  0D
0394:  MOVLW  00
0395:  MOVWF  0F
0396:  BCF    03.0
0397:  MOVLW  05
0398:  BCF    03.6
0399:  MOVWF  46
*
03F0:  MOVLW  10
03F1:  MOVWF  04
03F2:  MOVF   43,W
03F3:  MOVWF  47
03F4:  MOVF   42,W
03F5:  MOVWF  46
03F6:  CALL   2F3
03F7:  MOVLW  7C
03F8:  MOVWF  4F
03F9:  CALL   19A
03FA:  MOVLW  10
03FB:  MOVWF  04
03FC:  MOVF   45,W
03FD:  MOVWF  47
03FE:  MOVF   44,W
03FF:  MOVWF  46
0400:  CALL   2F3
....................    WriteLCDLine1(&lcdBuffer); 
0401:  CLRF   47
0402:  MOVLW  21
0403:  MOVWF  46
.................... } 
....................  
.................... void main() { 
*
0421:  MOVF   03,W
0422:  ANDLW  1F
0423:  MOVWF  03
0424:  MOVLW  FF
0425:  MOVWF  20
0426:  CLRF   32
0427:  CLRF   31
0428:  BSF    03.5
0429:  BSF    1F.0
042A:  BSF    1F.1
042B:  BSF    1F.2
042C:  BCF    1F.3
042D:  MOVLW  07
042E:  MOVWF  1C
042F:  BCF    03.7
....................    SetupCommunication(); 
0430:  BCF    03.5
0431:  GOTO   01D
....................    SetupCan(); 
0432:  GOTO   08D
....................    //SetupTimers(); 
....................    LCDInitialize(); 
0433:  GOTO   149
....................     
....................    ClearLCDBuffer(); 
0434:  CALL   18C
....................    sprintf(lcdBuffer, "HELLO WORLD"); 
0435:  CLRF   32
0436:  MOVLW  21
0437:  MOVWF  31
0438:  MOVLW  0F
0439:  BSF    03.6
043A:  MOVWF  0D
043B:  MOVLW  00
043C:  MOVWF  0F
043D:  BCF    03.6
043E:  CALL   1A7
....................    WriteLCDLine0(&lcdBuffer); 
043F:  CLRF   43
0440:  MOVLW  21
0441:  MOVWF  42
0442:  CALL   27D
....................     
....................    delay_ms(500); 
0443:  MOVLW  02
0444:  MOVWF  33
0445:  MOVLW  FA
0446:  MOVWF  4C
0447:  CALL   079
0448:  DECFSZ 33,F
0449:  GOTO   445
....................     
....................    WriteLoop(); 
044A:  GOTO   356
.................... } 
....................  
044B:  SLEEP
.................... void ReadLoop() { 
....................    CAN_470 message; 
....................    Can_Id id; 
....................     
....................    ClearLCDBuffer(); 
....................    sprintf(lcdBuffer, "RX NODE"); 
....................    WriteLCDLine0(&lcdBuffer); 
....................     
....................    while (1) { 
....................       if (ReadMessage(0x470, &message, &id)) { 
....................          //PrintVelocity(message.seta_esquerda, id); 
....................       } 
....................        
....................       delay_ms(10); 
....................    } 
.................... } 
....................  
.................... void WriteLoop() { 
....................    CAN_200 reference; 
....................    CAN_201 enableControl; 
....................     
....................    ClearLCDBuffer(); 
*
0356:  CALL   18C
....................    sprintf(lcdBuffer, "TX NODE"); 
0357:  CLRF   32
0358:  MOVLW  21
0359:  MOVWF  31
035A:  MOVLW  19
035B:  BSF    03.6
035C:  MOVWF  0D
035D:  MOVLW  00
035E:  MOVWF  0F
035F:  BCF    03.6
0360:  CALL   1A7
....................    WriteLCDLine0(&lcdBuffer); 
0361:  CLRF   43
0362:  MOVLW  21
0363:  MOVWF  42
0364:  CALL   27D
....................     
....................    CanStructInit(&reference); 
0365:  CLRF   43
0366:  MOVLW  33
0367:  MOVWF  42
0368:  CALL   288
....................    reference.pedal_simulado = 5; 
0369:  MOVLW  05
036A:  MOVWF  36
....................     
....................    CanStructInit(&enableControl); 
036B:  CLRF   43
036C:  MOVLW  3B
036D:  MOVWF  42
036E:  CALL   288
....................    enableControl.modo_pedal_sim = 1; 
036F:  MOVLW  01
0370:  MOVWF  3E
....................    enableControl.modo_operacao = 0; 
0371:  CLRF   3F
....................    enableControl.ref_marcha_lenta = 0; 
0372:  CLRF   40
....................     
....................    delay_ms(50); 
0373:  MOVLW  32
0374:  MOVWF  4C
0375:  CALL   079
....................        
....................    int pedal = 0; 
0376:  CLRF   41
....................    while (1) { 
....................       pedal = pedal + 1; 
0377:  MOVLW  01
0378:  ADDWF  41,F
....................       if (pedal >= 40) pedal = 0; 
0379:  MOVF   41,W
037A:  SUBLW  27
037B:  BTFSS  03.0
037C:  CLRF   41
....................       reference.pedal_simulado = pedal; 
037D:  MOVF   41,W
037E:  MOVWF  36
....................       CanSetSendAddress(0x200); 
037F:  MOVLW  02
0380:  MOVWF  43
0381:  CLRF   42
0382:  CALL   2A0
....................       SendCanFrame(&reference); 
0383:  CLRF   43
0384:  MOVLW  33
0385:  MOVWF  42
0386:  CALL   2CE
....................       PrintPedal(pedal, 0x200); 
0387:  CLRF   43
0388:  MOVF   41,W
0389:  MOVWF  42
038A:  MOVLW  02
038B:  MOVWF  45
038C:  CLRF   44
....................        
....................       delay_ms(150); 
*
040E:  MOVLW  96
040F:  MOVWF  4C
0410:  CALL   079
....................       CanSetSendAddress(0x201); 
0411:  MOVLW  02
0412:  MOVWF  43
0413:  MOVLW  01
0414:  MOVWF  42
0415:  CALL   2A0
....................       SendCanFrame(&enableControl); 
0416:  CLRF   43
0417:  MOVLW  3B
0418:  MOVWF  42
0419:  CALL   2CE
....................       delay_ms(150); 
041A:  MOVLW  96
041B:  MOVWF  4C
041C:  CALL   079
041D:  GOTO   377
....................    } 
041E:  BCF    0A.3
041F:  BCF    0A.4
0420:  GOTO   44B (RETURN)
.................... } 
....................  

Configuration Fuses:
   Word  1: 3F32   HS NOWDT PUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
